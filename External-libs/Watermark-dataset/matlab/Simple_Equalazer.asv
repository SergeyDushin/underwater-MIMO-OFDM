 %function [symbols_PFFT] = Simple_Equalazer(QPSK_symbols, demod_sig,method,PIL,LMSG,LMSM,crr_grd,which_plots,I)       

function y_Equalized = Simple_Equalazer(tx_s, rx_s, h)
%             % Переменные: tx_s - перденный сигнал, rx_s - принятый сигнал,
%             % h- импульсная характерстика канала.
%             % tx_s передаются для выбора пилотов
%             % h - для сравнения результатов
% 


y_Equalized  =  0*rx_s;
N  = length(rx_s(1,:)); % количество блоков
K  = length(rx_s(:,1)); % количество несущеих 


%% Линейный жквалазей RLS     Эквализация для каждой несущей
          
eq = comm.LinearEqualizer('Algorithm','LMS','NumTaps',10,'StepSize',0.003);
eq = comm.LinearEqualizer('Algorithm','RLS','NumTaps',2, 'ForgettingFactor', 0.99);
eq.ReferenceTap = 1;
    

% eq = comm.LinearEqualizer('Algorithm','CMA','AdaptWeights',false,'InitialWeightsSource','Property')
% eq.ReferenceTap = 30;
% mxStep = maxstep(eq,rx)


for k=1:K     
    [y,err,weights] = eq(rx_s(k,:)',tx_s(k,:)');    
    y_Equalized(k,:)=y';  
end


% %% MLSE эвалазйер
% 
% mlse = comm.MLSEEqualizer('TracebackDepth',10, 'Channel', h(10,[1:10])');
% 
% for k = 1:K     
%     % Equalize the channel output and demodulate.
%     y = mlse(rx_s(k,:)');  
%     y_Equalized(k,:)=y';  
% end

%% Прямое нахождение передаточной функции
% 
% for k=1:N   
%     hTemp=h(k,[1:length(rx_s(:,1))])';
%     H_k= fft(hTemp);
% % Equalize the signal.
% eqH = conj(hTemp)./(conj(hTemp).*hTemp);
% x_k=rx_s(:,k);
% y_Equalized(:,k) = eqH.*x_k;
%     
% end



%%
% Раскомментировать,  если без эквалайзера      
%y_Equalized  =  tx_s; % без канала и эквалайзера
%y_Equalized  =  rx_s;  % без эквалайзера, но с каналом



end   
